<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Creating distributed objects</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>The &#39;ddR&#39; package aims to provide an unified R interface for writing
parallel and distributed applications.  Our goal is to ensure that R
programs written using the &#39;ddR&#39; API work across different distributed
backends, therefore, reducing the effort required by users to
understand and program on different backend infrastructures.  Currently &#39;ddR&#39;
programs can be executed on R&#39;s default &#39;parallel&#39; package as well as
the open source HP Distributed R.  We plan to add support for
SparkR. This package is an outcome of feedback and collaboration
across different companies and R-core members!</p>

<p>&#39;ddR&#39; is an API, and includes a default execution engine, to express
and execute distributed applications. Users can declare distributed
objects (i.e., <code>dlist</code>, <code>dframe</code>, <code>darray</code>), and execute parallel
operations on these data structures using R-style <code>apply</code>
functions. It also allows different backends (that support ddR, and
have ddR &ldquo;drivers&rdquo; written for them) to be dynamically activated in
the R user&#39;s environment to execute applications</p>

<p>To get started, first install the &#39;ddR&#39; package using
<code>install.packages(&quot;ddR&quot;)</code>.  Next, load the library. By default the
package will use R&#39;s &#39;parallel&#39; package as the backend. If you&#39;d like
to use a custom backend you will need to first install that backend
and the &#39;ddR&#39; driver for that backend.  For example, if you&#39;d like to
use HP Distributed R, you will need to first install the
<code>distributedR</code> package followed by the the driver <code>distributedR.ddR</code>.</p>

<pre><code class="r">library(ddR)
## Run the next two lines also to use the Distributed R backend
# library(distributedR.ddR)
# useBackend(distributedR)
</code></pre>

<p>By default, the <code>parallel</code> backend is used with all the cores present
on the machine. You can switch backends or specify the number of cores
to use with the <code>useBackend</code> function. For example, you can specify
that the <code>parallel</code> backend should be used with only 4 cores by
executing <code>useBackend(parallel, executors=4)</code>. If you want to use SNOW
based backend (also exported by <code>parallel</code>), you can set the <code>type</code>
field to use sockets: <code>useBackend(parallel, type=&quot;PSOCK&quot;,
executors=4)</code>. This command will launch four R processes that use
sockets to communicate with each other. If the type field is not used,
then the default is to fork multiple processes (not available on
Windows).</p>

<h3>Creating distributed objects</h3>

<p>There are two ways to create distributed objects in &#39;ddR&#39;.</p>

<ol>
<li>Using the constructor functions.</li>
<li>Using <code>dmapply</code> or <code>dlapply</code> (<code>dlists</code> only).</li>
</ol>

<h2>Using constructor functions</h2>

<p>A distributed list (<code>dlist</code>) may be created using the constructor with a comma-separated list of arguments. For example:</p>

<pre><code class="r">my.dlist &lt;- dlist(1,2,3,4,5)
my.dlist
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: dlist
## # of partitions: 5
## Partitions per dimension: 5x1
## Partition sizes: [1], [1], [1], [1], [1]
## Length: 5
## Backend: parallel
</code></pre>

<p>Note that the output shows you a lot of useful information, including
metadata about the object, partition sizes, etc. There are 5
partitions in <code>my.dlist</code>, because by default, the constructor creates
as many partitions as the elements in input.</p>

<p>However, you may also specify the partitioning directly using the constructor:</p>

<pre><code class="r">my.dlist &lt;- dlist(1,2,3,4,5,nparts=3)
my.dlist
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: dlist
## # of partitions: 3
## Partitions per dimension: 3x1
## Partition sizes: [2], [2], [1]
## Length: 5
## Backend: parallel
</code></pre>

<p>When <code>nparts</code> is supplied, it will create the requested number of
partitions in the output object, with a best effort splitting of data
between those partitions. In this case, since 5 isn&#39;t divisible by 3,
it divides data into groups of 2, 2, and 1.</p>

<p>The constructors for <code>darray</code> and <code>dframe</code> are different. For example, you may initialize a <code>darray</code> in the following manner:</p>

<pre><code class="r">my.darray &lt;- darray(dim=c(4,4),psize=c(2,2),data=3)
my.darray
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: darray
## # of partitions: 4
## Partitions per dimension: 2x2
## Partition sizes: [2, 2], [2, 2], [2, 2], [2, 2]
## Dim: 4,4
## Backend: parallel
</code></pre>

<p>This makes <code>my.darray</code> a <code>darray</code> that is filled with 3. Each
partition is of size 2x2, and the dimension of <code>my.darray</code> is
4x4. For <code>dframe</code>, the constructor has the same format.</p>

<h2>Using <code>dmapply</code> or <code>dlapply</code></h2>

<p>Constructors are handy when you want to initialize distributed objects
quickly. However, the flexible way to create distributed objects is
via <code>dmapply</code> and <code>dlapply</code>. Similar to the functional-programming
behavior of R&#39;s mapply and lapply, distributed functions in &#39;ddR&#39; also
return new objects.</p>

<p>Below is an example on how to create the same <code>dlist</code> as before but by
using <code>dlapply</code>:</p>

<pre><code class="r">my.dlist &lt;- dlapply(1:5,function(x) x)
my.dlist
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: dlist
## # of partitions: 5
## Partitions per dimension: 5x1
## Partition sizes: [1], [1], [1], [1], [1]
## Length: 5
## Backend: parallel
</code></pre>

<p>Why does it work? The distributed <code>lapply</code> function, <code>dlapply</code>,
executes on the function argument vector <code>1:5</code>, assigning to each
element the value of the vector for that iteration. To specify
<code>nparts</code>, you can also supply <code>nparts</code>, just as in the constructor
function:</p>

<pre><code class="r">my.dlist &lt;- dlapply(1:5,function(x) x, nparts=3)
my.dlist
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: dlist
## # of partitions: 3
## Partitions per dimension: 3x1
## Partition sizes: [2], [2], [1]
## Length: 5
## Backend: parallel
</code></pre>

<p>The behavior of <code>dmapply</code> for <code>darray</code> and <code>dframe</code> is slightly
involved, though not substantially so. When creating these data
structures using <code>dmapply</code>, the API needs to know some information,
such as how to partition the output in 2d-manner, as well as how to
combine intermediate results of dmapply within each
partition. Therefore, you may need to also supply arguments for the
following parameters is you want to override the defaults:</p>

<ol>
<li><code>output.type</code>, as either <code>&quot;darray&quot;</code> or <code>&quot;dframe&quot;</code> (default is <code>&quot;dlist&quot;</code>).</li>
<li><code>nparts</code>. Instead of just a scalar value, this parameter needs to be a vector of length 2, in order to specify how to two-dimensionally partition the output <code>darray</code> or <code>dframe</code>. For example, <code>nparts=c(2,2)</code> means you want the four partitions resulting from <code>dmapply</code> to be stitched together in a 2 by 2 fashion. We expect most people to use only single dimension such as row partitioned data, <code>nparts=c(N,1)</code>.</li>
<li><code>combine</code> This argument is needed to fit the output of <code>dmapply</code> into the correct number of partitions. For example, there may be cases where <code>dmapply</code> returns 10 elements, but you have specified only 4 partitions in your output via <code>nparts</code>. In such as case, <code>combine</code> allows you to specify how elements should be combined to form only 4 partitions. You may like to think of this operation as what is called within each partition together on the results, to fit the output partitioning. <code>combine</code> can be either <code>c</code> (default), <code>rbind</code>, or <code>cbind</code>.</li>
</ol>

<p>So, let&#39;s create a 4x4 <code>darray</code>, consisting of 4 2x2 partitions, where each partition contains values equal to its partition identifier:</p>

<pre><code class="r">my.darray2 &lt;- dmapply(function(x) matrix(x,2,2), 1:4, output.type=&quot;darray&quot;, combine=&quot;rbind&quot;, nparts=c(2,2))
my.darray2
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: darray
## # of partitions: 4
## Partitions per dimension: 2x2
## Partition sizes: [2, 2], [2, 2], [2, 2], [2, 2]
## Dim: 4,4
## Backend: parallel
</code></pre>

<p>Even though we didn&#39;t <code>rbind</code> anything, as each iteration of <code>dmapply</code>
was one partition of the result, the <code>combine</code> value was necessary.
Since the default value of <code>combine</code> is <code>c</code>, which flattens and
vectorizes the results within each partition (this is the default
behavior of R&#39;s <code>mapply</code>). So <code>rbind</code> prevents this from happening,
and the matrix structure is retained. We can look at what&#39;s stored in
<code>my.darray2</code> by using the <code>collect</code> operator, which brings the data
from the distributed backend to the local R instance, as a local R
object:</p>

<pre><code class="r">my.array &lt;- collect(my.darray2)
my.array
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    1    2    2
## [2,]    1    1    2    2
## [3,]    3    3    4    4
## [4,]    3    3    4    4
</code></pre>

<h3>Collect() and parts()</h3>

<p>As mentioned above, <code>collect</code> allows you to gather data from the
partitions of a distributed object and convert it into a local R
object.</p>

<p>You can gather individual partitions of the distributed object by
using the second parameter of <code>collect</code>. For example, to get the third
partition of our previous darray, <code>my.array2</code>, you can write:</p>

<pre><code class="r">collect(my.darray2,3)
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    3    3
## [2,]    3    3
</code></pre>

<p><code>parts</code> is a construct which takes a distributed object, and returns a
<code>list</code> of new distributed objects, each of which represents one
partition of the original distributed object. For example, let&#39;s take
a look at <code>my.darray2</code> again:</p>

<pre><code class="r">my.darray2
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: darray
## # of partitions: 4
## Partitions per dimension: 2x2
## Partition sizes: [2, 2], [2, 2], [2, 2], [2, 2]
## Dim: 4,4
## Backend: parallel
</code></pre>

<p>Let&#39;s call <code>parts</code> on it:</p>

<pre><code class="r">parts(my.darray2)
</code></pre>

<pre><code>## [[1]]
## 
## ddR Distributed Object
## Type: darray
## # of partitions: 1
## Partitions per dimension: 1x1
## Partition sizes: [2, 2]
## Dim: 2,2
## Backend: parallel
## 
## [[2]]
## 
## ddR Distributed Object
## Type: darray
## # of partitions: 1
## Partitions per dimension: 1x1
## Partition sizes: [2, 2]
## Dim: 2,2
## Backend: parallel
## 
## [[3]]
## 
## ddR Distributed Object
## Type: darray
## # of partitions: 1
## Partitions per dimension: 1x1
## Partition sizes: [2, 2]
## Dim: 2,2
## Backend: parallel
## 
## [[4]]
## 
## ddR Distributed Object
## Type: darray
## # of partitions: 1
## Partitions per dimension: 1x1
## Partition sizes: [2, 2]
## Dim: 2,2
## Backend: parallel
</code></pre>

<p>In the above example the output is a list of length 4, where each item
is itself a <code>darray</code>, with partitioning and size equal to one
partition of the original. We can also subset using <code>parts</code> to obtain
just the second and third parts, respectively.</p>

<pre><code class="r">parts(my.darray2,2:3)
</code></pre>

<pre><code>## [[1]]
## 
## ddR Distributed Object
## Type: darray
## # of partitions: 1
## Partitions per dimension: 1x1
## Partition sizes: [2, 2]
## Dim: 2,2
## Backend: parallel
## 
## [[2]]
## 
## ddR Distributed Object
## Type: darray
## # of partitions: 1
## Partitions per dimension: 1x1
## Partition sizes: [2, 2]
## Dim: 2,2
## Backend: parallel
</code></pre>

<p>The primary use of <code>parts</code> is to execute <code>dmapply</code> on partitions of
the distributed objects.  This is explained more in the next section.</p>

<h3>Performing &ldquo;work&rdquo; with dmapply</h3>

<p>When performing any computation with <code>dmapply&#39;, the inputs to the
function can be any combination of distributed objects (</code>dlist<code>,
</code>dframe<code>,</code>darray<code>),</code>parts<code>of distributed objects, and standard R
objects. More specifically,</code>dlapply<code>and</code>dmapply statements
generally take the following form:</p>

<pre><code class="r">dlist1 &lt;- dlapply(arg,FUN,nparts)
dlist2 &lt;- dmapply(FUN,arg1,arg2,MoreArgs,nparts)
darray.or.dframe &lt;- dmapply(FUN,arg1,arg2,MoreArgs,output.type,combine,nparts)
</code></pre>

<p>Valid types for the above arguments are the following:</p>

<ol>
<li><code>FUN</code>: any function with one or more arguments, defined using <code>function</code> in R.</li>
<li><code>arg*</code>: any iterable collection
1) R objects: <code>list</code>, <code>data.frame</code>, <code>matrix</code>, any R vector, e.g., <code>1:10</code>, or <code>c(1,3,2)</code>
2) distributed objects: <code>dlist</code>, <code>dframe</code>, and <code>darray</code>
3) <code>parts</code> of distributed objects <code>dlist</code>, <code>dframe</code>, and <code>darray</code></li>
<li><code>MoreArgs</code>: a <code>list</code> of (usually named) items that are also arguments to <code>FUN</code>, but are not iterated over, and instead passed to each iteration of the <code>dmapply</code> as a whole.</li>
<li><code>output.type</code>: a string of either <code>dlist</code>, <code>darray</code>, <code>dframe</code>, or <code>sparse_darray</code>. By default, it is <code>dlist</code>.</li>
<li><code>combine</code>: a string of either <code>default</code>, <code>rbind</code>, <code>cbind</code>, or <code>c</code>. The default <code>default</code> means <code>c</code> for <code>darray</code> and <code>dframe</code>, but nothing for <code>dlist</code>. For more information, please consult the user guide.</li>
<li><code>nparts</code>: A numeric vector, of length 1 or 2. <code>dlist</code> objects can only have 1d-partitioning, but <code>darray</code> and <code>dframe</code> objects have 2d-partitioning. </li>
</ol>

<p>When distributed objects are passed in <code>dmapply</code>, the semantics is
same as R&#39;s <code>lapply</code> and <code>mapply</code> on regular R objects. This means <code>FUN</code> is applied
per column in a <code>dframe</code>, once per item for <code>dlist</code> objects, and once per
element (in column-major order) for <code>darray</code> objects.</p>

<p>When <code>parts</code> is used, a list of partitions of the underlying
distributed object is returned. Therefore, <code>dmapply</code> operates on the
list in the traditional manner, which means the function <code>FUN</code> is
applied to each partition of the distributed object. </p>

<p>Scroll to end of this document for more examples on how to use
<code>dmapply</code> on distributed objects and their partitions.</p>

<h3>Operators</h3>

<p>&#39;ddR&#39; supports a number of R-style, R-equivalent, operations on
distributed objects. These are implemented &ldquo;generically&rdquo; based on
<code>dmapply</code>, so they should work on all supported backends.</p>

<p>Examples:</p>

<pre><code class="r">## Head and tail
head(my.darray2,n=1)
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    1    2    2
</code></pre>

<pre><code class="r">tail(my.darray2,n=1)
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    3    3    4    4
</code></pre>

<pre><code class="r">## Subsetting
my.darray2[2,c(2,1)]
</code></pre>

<pre><code>## [1] 1 1
</code></pre>

<pre><code class="r">## Statistics
colSums(my.darray2)
</code></pre>

<pre><code>## [1]  8  8 12 12
</code></pre>

<pre><code class="r">max(my.darray2)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<p>There are many more!</p>

<h3>Repartitioning</h3>

<p>You may sometimes like to repartition your data. This can be done with the <code>repartition</code> command.</p>

<p>Say you have a 4x4 <code>darray</code> filled with 3:</p>

<pre><code class="r">da &lt;- darray(psize=c(2,2),dim=c(4,4),data=3)
da
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: darray
## # of partitions: 4
## Partitions per dimension: 2x2
## Partition sizes: [2, 2], [2, 2], [2, 2], [2, 2]
## Dim: 4,4
## Backend: parallel
</code></pre>

<p><code>da</code> is currently partitioned into 4 pieces of 2x2 arrays. You could
repartition it to be two parts of 4x2 arrays. Currently this requires
you to have another <code>skeleton</code> object against which to repartition
your input. This object acts as the &ldquo;model&rdquo; by which your input should
be repartitioned. The skeleton should have the same dimensions as the
input, but a different partitioning scheme. For example:</p>

<pre><code class="r">skel &lt;- darray(psize=c(4,2),dim=c(4,4),data=0)
</code></pre>

<p><code>skel</code>, like <code>da</code>, is also a 4x4 darray, but it is partitioned
differently. In such cases <code>repartition(input,skeleton)</code> can be used
to return a new distributed object that retains the data of <code>input</code>,
but has the partitioning scheme of <code>skeleton</code>:</p>

<pre><code class="r">da &lt;- repartition(da,skel)
da
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: darray
## # of partitions: 2
## Partitions per dimension: 1x2
## Partition sizes: [4, 2], [4, 2]
## Dim: 4,4
## Backend: parallel
</code></pre>

<p>As you can see, <code>da</code> is now partitioned just like <code>skel</code>. Executing
<code>collect</code> shows that it still has the same data as before:</p>

<pre><code class="r">collect(da)
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    3    3    3    3
## [2,]    3    3    3    3
## [3,]    3    3    3    3
## [4,]    3    3    3    3
</code></pre>

<p>Note that <code>repartition</code> may be called implicitly and automatically by
some backends during <code>dmapply</code> or <code>dlapply</code>. If the inputs and outputs
(based on <code>nparts</code>) are not partitioned compatibly, each execution
unit may not have the data required to process its chunk of
computation. In this case, the backend may automatically call
<code>repartition</code> on one or more of your inputs. In this case, performance
may be impacted, so it is good practice to learn what results in
compatible partitioning.</p>

<h3>More Examples</h3>

<p>Initializing a distributed list (<code>dlist</code>):</p>

<pre><code class="r">a &lt;- dmapply(function(x) { x }, rep(3,5))
collect(a)
</code></pre>

<pre><code>## [[1]]
## [1] 3
## 
## [[2]]
## [1] 3
## 
## [[3]]
## [1] 3
## 
## [[4]]
## [1] 3
## 
## [[5]]
## [1] 3
</code></pre>

<p>Printing <code>a</code>:</p>

<pre><code class="r">a
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: dlist
## # of partitions: 5
## Partitions per dimension: 5x1
## Partition sizes: [1], [1], [1], [1], [1]
## Length: 5
## Backend: parallel
</code></pre>

<p><code>a</code> is a distributed object in ddR. Note that we did not specify the
number of partitions of the output, but by default it is equal to the
length of the inputs (5). Use the parameter <code>nparts</code> to specify how
the output should be partitioned:</p>

<p>Below is the code to add 1 to the first element of <code>a</code>, 2 to the
second, etc. The syntax of <code>dmapply</code> is similar to R&#39;s standard
<code>mapply</code> function.</p>

<pre><code class="r">b &lt;- dmapply(function(x,y) { x + y }, a, 1:5,nparts=1)
b
</code></pre>

<pre><code>## 
## ddR Distributed Object
## Type: dlist
## # of partitions: 1
## Partitions per dimension: 1x1
## Partition sizes: [5]
## Length: 5
## Backend: parallel
</code></pre>

<p>As you can see, <code>b</code> only has one partition of 5 elements.</p>

<pre><code class="r">collect(b)
</code></pre>

<pre><code>## [[1]]
## [1] 4
## 
## [[2]]
## [1] 5
## 
## [[3]]
## [1] 6
## 
## [[4]]
## [1] 7
## 
## [[5]]
## [1] 8
</code></pre>

<p>Some other operations:
</p>

<p>Adding <code>a</code> to <code>b</code>, then subtracting a constant value</p>

<pre><code class="r">addThenSubtract &lt;- function(x,y,z) {
  x + y - z
}
c &lt;- dmapply(addThenSubtract,a,b,MoreArgs=list(z=5))
collect(c)
</code></pre>

<pre><code>## [[1]]
## [1] 2
## 
## [[2]]
## [1] 3
## 
## [[3]]
## [1] 4
## 
## [[4]]
## [1] 5
## 
## [[5]]
## [1] 6
</code></pre>

<p>Accessing dobjects by parts:</p>

<pre><code class="r">d &lt;- dmapply(function(x) length(x),parts(a))
collect(d)
</code></pre>

<pre><code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1
## 
## [[4]]
## [1] 1
## 
## [[5]]
## [1] 1
</code></pre>

<p>We partitioned <code>a</code> with 5 parts and it had 5 elements, so the length of each partition is of course 1.</p>

<p>However, <code>b</code> only had one partition, so that one partition should be of length 5:</p>

<pre><code class="r">e &lt;- dmapply(function(x) length(x),parts(b))
collect(e)
</code></pre>

<pre><code>## [[1]]
## [1] 5
</code></pre>

<p>For more example, check out our GitHub repo: <a href="https://github.com/vertica/ddR">https://github.com/vertica/ddR</a></p>

<h2>Using the Distributed R backend</h2>

<p>To use the Distributed R library for ddR, first install <code>distributedR</code> from <a href="https://github.com/vertica/DistributedR">https://github.com/vertica/DistributedR</a>
and <code>distributedR.ddR</code> from <a href="https://github.com/vertica/ddR">https://github.com/vertica/ddR</a>.</p>

<p>Load the Distributed R driver library for ddR:</p>

<pre><code class="r">library(distributedR.ddR)
</code></pre>

<pre><code>## Loading required package: distributedR
## Loading required package: Rcpp
## Loading required package: RInside
## Loading required package: XML
## Loading required package: ddR
## 
## Attaching package: &#39;ddR&#39;
## 
## The following objects are masked from &#39;package:distributedR&#39;:
## 
##     darray, dframe, dlist, is.dlist
</code></pre>

<pre><code class="r">useBackend(distributedR)
</code></pre>

<pre><code>## Master address:port - 127.0.0.1:50000
</code></pre>

<p>Now you can try the different examples above which were used with the &#39;parallel&#39; backend!</p>

</body>

</html>
